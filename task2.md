При первом REST Запросе мы получаем снэпшот по текущему состоянию.
Это состояние можно увидеть в поле sequence.

```Пример запроса для orderbook ```

![image](https://user-images.githubusercontent.com/53054649/208065770-2655cc54-956e-49b9-b086-7b6bd59482b5.png)

```Вызов в терминале ```

![image](https://user-images.githubusercontent.com/53054649/208065927-a224f25b-f2bc-4fe8-990e-3ffe2931e0ab.png)



Далее происходит подписка на стримы с помощью ws. 
По этим стримам нам приходят обновления в закодированном Base64 виде 
```Пример приходящего сообщения по подписке ```
![image](https://user-images.githubusercontent.com/53054649/208066372-49e3502e-ddfc-4104-adc3-b5e89b3dd1af.png)

Мы можем раскодировать сообщение для наглядности

```Вывод раскодированного по подписке сообщения ```
![image](https://user-images.githubusercontent.com/53054649/208067786-1c222c58-7810-4f8b-9fb4-31be73fc70de.png)
Увидим, что нам приходят новые данные, и sequence последовательность.

Далее происходит следующий алгоритм, мы отбрасываем все сообщения сокета, порядковый номер которых меньше или равен заголовку последовательности, полученному из вызова REST.
Применяем остальные сообщения сокета по порядку поверх результатов вызова REST. Объекты, полученные в дельтах сокетов, имеют те же схемы, что и объекты, возвращаемые REST API. 
Каждая дельта сокета представляет собой моментальный снимок объекта. Чтобы применить дельты сокетов к локальному кэшу данных, просто заменяем объекты в кэше объектами, поступающими из сокета, ключи которого совпадают.
Продолжаем применять сообщения по мере их получения из сокета до тех пор, пока порядковый номер в потоке всегда увеличивается на 1 для каждого сообщения
Если получено сообщение, которое не является следующим по порядку, то начинаем ставить сообщения в очередь без их обработки и вызываем эквивалентный REST API, записывая как результаты, так и значение возвращаемого заголовка последовательности 
